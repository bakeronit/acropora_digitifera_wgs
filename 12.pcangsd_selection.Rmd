---
title: "PCAngsd-based Selection Analysis"
output: 
  github_document
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.retina = 2)
library(tidyverse)
library(ggpubr)
```

For the Western Australian data we found that PCA analysis with PCAngsd separates the three populations based on two PC axes.  PC1 predominantly separates inshore from offshore samples whereas PC2 separates the two offshore locations from each other. 

```{r make table}
# Read sample information and construct a sample table

samples <- read_tsv("data/hpc/pcangsd/samples.txt",col_names = c("sample_id","location","mapping_rate","mean_mapping_depth","genome_cov"))

sample_table_wa <- read_tsv("data/hpc/pcangsd/wa_bam.txt",col_names = "filename") %>% 
    mutate(sample_id = str_replace(filename,"_S[0-9]+$","")) %>% 
  left_join(samples) %>% 
  rownames_to_column("number")
```

```{r pcangsd-wa-pca}
covmat_wa <- read_table2("data/hpc/pcangsd/wa.cov",col_names = FALSE) %>% 
  as.matrix()

pop_eigen_wa <- eigen(covmat_wa)
eigenvalues_wa <- round(pop_eigen_wa$values,1)

pop_pca_wa <- data.frame(e1=pop_eigen_wa$vectors[,1],e2=pop_eigen_wa$vectors[,2]) %>% cbind(sample_table_wa)

pclabel <- function(pcnum,eigenvalues){
  paste("PC",pcnum," (",eigenvalues[pcnum],"%)",sep = "")
}

pop_pca_wa %>% 
  filter(!sample_id=="BR_5_121") %>% 
  ggplot(aes(x=e1,y=e2)) + 
  geom_point(aes(color=location),size=1) + 
  theme_pubr() + xlab(pclabel(1,eigenvalues_wa)) + 
  ylab(pclabel(2,eigenvalues_wa)) + 
  theme(legend.title = element_blank())
```


**Figure 1:** PCA showing separation of Western Australian *A. digitifera* samples along PC1 and PC2.

A new version of PCAngsd ( [@Meisner2021-um] ) implements selection scans by extending two methods (FastPCA and pcadapt) to work with low coverage data.  Even though our data is not strictly low coverage it is worth exploring this analysis as it is easy and fast, and also provides an indication of what selective sweeps can be detected using a method that completely avoids any issues related to genotyping bias. 

To do this we first called SNPs and calculated genotype likelihoods as follows;

```bash
angsd -b wa_bam.txt -out all -GL 2 -nThreads 8 -doGlf 2 -SNP_pval 1e-6 -doMajorMinor 1 -doMaf 2 -doCounts 1 -minMaf 0.05 -minInd 67 -minMapQ 20 -minQ 20 -setMinDepth 750 -setMaxDepth 2500 -setMinDepthInd 3
```

Then ran PCAngsd (v1.0) as follows;

```bash
python pcangsd/pcangsd.py -beagle wa.beagle.gz	-out wa	-threads 32	-admix	-selection	-pcadapt	-selection_e 2	-snp_weights	-maf_save	-pi_save  	-dosage_save  	-sites_save 	-tree 
```

```{r}
library(RcppCNPy)
library(bigutilsr)

zscores <- npyLoad("data/hpc/pcangsd/wa.pcadapt.zscores.npy")
galinsky <- npyLoad("data/hpc/pcangsd/wa.selection.npy")

sites_binary <- read_tsv("data/hpc/pcangsd/wa.sites",col_names = c("included"))
#d_scores <- dist_ogk(raw_scores)
K <- ncol(zscores)

# For one component only
if (K == 1) {
	d2 <- (zscores - median(zscores))^2
} else {
  # Calculates robus Mahalanobis (squared) distances
	d2 <- dist_ogk(zscores)
}

pvals <- pchisq(d2,df=K,lower.tail = F)
write_rds(pvals,"cache/pcadapt_pvals.rds")
```

For the first statistic (FastPCA / Galinsky statistic) we have one value for each of the PCs, whereas for pcadapt a single statistic based on robust Mahalanobis distance is used to summarise both PCs.  Examination of the distribution of p-values genome-wide in this case suggests that pcadapt is able to detect many significant loci under selection, whereas the Galinsky statistics are not.

```{r pca-score-histo}
score_data <- data.frame(galinsky,pcadapt_pval = pvals) %>% 
  mutate(galinsky_pc1 = pchisq(X1,df=1,lower.tail = F)) %>% 
  mutate(galinsky_pc2 = pchisq(X2,df=1,lower.tail = F)) %>% 
  select(-X1,-X2) %>% 
  pivot_longer(everything(),names_to = "name") %>% 
  slice_sample(n=100000)


ggplot(score_data) + geom_histogram(aes(x=value), binwidth = 0.01) + facet_wrap(~name, ncol = 1, scales = "free")
```

**Figure 2:** Histograms of raw p-values for selection statistics calculated by PCAngsd.

For the pcadapt statistic we create a Manhattan plot to view sites under selection across the genome.  Note that this uses Pseudo-chromosome level coordinates obtained via [RagTag](11.ragtag_scaffolding.md). This command converts coordinates into this pseudo-chromosome system

```bash
./translate_coords.py ../pcangsd/wa.positions.txt ragtag_output/ragtag.scaffolds.agp > ../pcangsd/wa.positions.scaf.txt
```

```{r pcadapt-manhattan-plot}

coordinates <- read_tsv("data/hpc/pcangsd/wa.positions.scaf.txt",col_names = c("scaffold","pos"))
coordinates_included <- coordinates[sites_binary$included==1,] %>% mutate(p=row_number())

lengths <- read_tsv("data/hpc/pcangsd/all.lengths.scaf.txt",col_names = c("scaffold","length"))
offsets <- lengths %>% arrange(desc(length)) %>% mutate(offset=cumsum(length)-length) %>% 
  mutate(scaffold_num = row_number())

manhattan_data <- coordinates_included %>% 
  left_join(offsets,by="scaffold") %>% 
  mutate(abs_pos = pos+offset) %>% 
  add_column(pval=-log10(pvals))

manhattan_data %>% 
  filter(pval>10) %>% 
  ggplot() + 
  geom_point(aes(x=abs_pos/1e6,y=pval,color=as.character(scaffold_num %% 2)),size=0.1) + ylab("-log10(p)") + xlab("Genome Position / Mb") + 
  geom_point(data = manhattan_data %>% filter(pval>200),aes(x=abs_pos/1e6,y=pval,color=as.character(scaffold_num %% 2)),size=2) + ylab("-log10(p)") + xlab("Genome Position / Mb") + 
    theme_pubclean() + theme(legend.position = "None")

write_rds(manhattan_data,file="cache/pcadapt.rds")
```


**Figure 3:** Manhattan plot showing the location of sites highly associated with population structure (-10log(p) > 10) across the genome
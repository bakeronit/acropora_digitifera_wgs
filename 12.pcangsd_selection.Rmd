---
title: "Selection analyses based on allele-frequency"
output: 
  github_document
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.retina = 2)
library(tidyverse)
library(ggpubr)
```

As a complement to the EHH-based scans for signatures of selection we also searched for signatures based on differences in allele frequency between populations. For this we used two approaches, both of which share a common core in the ANGSD framework. 

## Preliminary analyses with ANGSD

To support both approaches we first calculated allele frequencies and other statistics using ANGSD. Detailed shell scripts required to run these analyses can be found in `data/hpc/thetastat`.  A summary of the process is as follows;

1. Create a `sites.txt` file containing the coordinates of all high quality SNPs remaining in the final step of [02.quality_control.md](02.quality_control.md)
```bash
zcat Adigi.v2.filtered.vcf.gz | grep -v '^#' | awk 'BEGIN{OFS="\t"}{print $1,$2}' > sites.txt
angsd sites index sites.txt
```
2. Calculate the SFS separately for each population (see [here](data/hpc/thetastat/02_allele_freqs.sh) and [here](data/hpc/thetastat/03_realsfs.sh))
3. Export thetas (includes nucleotide diversity and Tajima\'s D) for each population in a sliding window
4. Calculate 2D SFS for each pair of populations
5. Export pairwise Fst for each pair of populations as well as the population branch statistic


### Population Branch Statistics

The population branch statistic is designed to measure [@Yi2010-br] the degree to which allele frequencies at a specific locus in one population have differentiated from other populations.  Using ANGSD we calculate this statistic in 50kb wide sliding windows and report it for each focal population 

```{r}
pbsdata <- read_tsv("data/hpc/thetastat/fst.slidingwindow.tsv",col_types = cols()) %>% 
  select(chr,midPos,Nsites,starts_with("PBS")) %>% 
  pivot_longer(starts_with("PBS"),names_to = "population",values_to="PBS")
```

To plot these values as a Manhattan plot we first convert coordinates into chromosomes

```bash
cd data/hpc/ragtag
./translate_coords.py <(cut -f2,3 ../thetastat/fst.slidingwindow.tsv | grep -v 'midPos') ragtag_output/ragtag.scaffolds.agp > ../thetastat/fst.slidingwindow.scafpos.tsv --keep
```

```{r pbs-manhattan-plot, cache=TRUE}
chr_positions <- read_tsv("data/hpc/thetastat/fst.slidingwindow.scafpos.tsv", col_types = cols(),
                          col_names = c("scaffold","scaffold_pos","chr","chr_pos")) %>% 
  unite("old_pos",scaffold,scaffold_pos,sep=":") %>% 
  unite("new_pos",chr,chr_pos,sep=":")

pbsdata_chr <- pbsdata %>% 
  unite("old_pos",chr,midPos,sep=":") %>% 
  left_join(chr_positions,by="old_pos") %>% 
  separate(new_pos, into=c("scaffold","position"), sep = ":",convert=TRUE)

lengths <- read_tsv("data/hpc/pcangsd/all.lengths.scaf.txt",col_names = c("scaffold","length"))
offsets <- lengths %>% arrange(desc(length)) %>% mutate(offset=cumsum(length)-length) %>% 
  mutate(scaffold_num = row_number())

manhattan_data <- pbsdata_chr %>% 
  left_join(offsets,by="scaffold") %>% 
  mutate(abs_pos = position+offset) 

manhattan_data$population <- factor(manhattan_data$population,labels=c("PBS0"="Inshore","PBS1"="North Offshore","PBS2"="South Offshore"))

manhattan_data %>% 
  ggplot() + 
  scale_x_discrete(labels=c("PBS0"="Inshore","PBS1"="North Offshore","PBS2"="South Offshore")) +
  geom_point(aes(x=abs_pos/1e6,y=PBS,color=as.character(scaffold_num %% 2)),size=0.1) + 
  ylab("Population Branch Statistic") + xlab("Genome Position / Mb") + 
  theme_pubclean() + theme(legend.position = "None") + facet_wrap(~population,ncol = 1)


write_rds(manhattan_data,file="cache/pbs.rds")
```

**Figure 1:** Manhattan plots showing the distribution of values of the population branch statistic (PBS) across the genome. Each plot shows PBS with a different focal population.

## PCAngsd

The next approach is based on the idea of [PCAdapt](https://pubmed.ncbi.nlm.nih.gov/27601374/) which used principle components analysis to search for markers that are related to population structure. This is implemented in a new version of PCAngsd ( [@Meisner2021-um] ) which supports selection scans by extending two methods (FastPCA and pcadapt) to work with low coverage data.  Even though our data is not strictly low coverage it is worth exploring this analysis as it is easy and fast, and also provides an indication of what selective sweeps can be detected using a method that completely avoids any issues related to genotyping bias. 

To do this we first called SNPs and calculated genotype likelihoods as follows;

```bash
angsd -b wa_bam.txt -out all -GL 2 -nThreads 8 -doGlf 2 -SNP_pval 1e-6 -doMajorMinor 1 -doMaf 2 -doCounts 1 -minMaf 0.05 -minInd 67 -minMapQ 20 -minQ 20 -setMinDepth 750 -setMaxDepth 2500 -setMinDepthInd 3
```

Then ran PCAngsd (v1.0) as follows;

```bash
python pcangsd/pcangsd.py -beagle wa.beagle.gz	-out wa	-threads 32	-admix	-selection	-pcadapt	-selection_e 2	-snp_weights	-maf_save	-pi_save  	-dosage_save  	-sites_save 	-tree 
```

```{r}
# Read sample information and construct a sample table

samples <- read_tsv("data/hpc/pcangsd/samples.txt",col_names = c("sample_id","location","mapping_rate","mean_mapping_depth","genome_cov"))

sample_table_wa <- read_tsv("data/hpc/pcangsd/wa_bam.txt",col_names = "filename") %>% 
  tidyr::extract(filename,into="sample_id",regex=".*/(.*_[A-Z,0-9]+_[0-9]+)_") %>% 
  #  mutate(sample_id = str_replace(filename,"_S[0-9]+$","")) %>% 
  left_join(samples) %>% 
  rownames_to_column("number")


covmat_wa <- read_table2("data/hpc/pcangsd/wa.cov",col_names = FALSE) %>% 
  as.matrix()

pop_eigen_wa <- eigen(covmat_wa)
eigenvalues_wa <- round(pop_eigen_wa$values,1)

pop_pca_wa <- data.frame(e1=pop_eigen_wa$vectors[,1],e2=pop_eigen_wa$vectors[,2]) %>% cbind(sample_table_wa)

pclabel <- function(pcnum,eigenvalues){
  paste("PC",pcnum," (",eigenvalues[pcnum],"%)",sep = "")
}

# pop_pca_wa %>% 
#   filter(!sample_id=="BR_5_121") %>% 
#   ggplot(aes(x=e1,y=e2)) + 
#   geom_point(aes(color=location),size=1) + 
#   theme_pubr() + xlab(pclabel(1,eigenvalues_wa)) + 
#   ylab(pclabel(2,eigenvalues_wa)) + 
#   theme(legend.title = element_blank())
```



```{r}
library(RcppCNPy)
library(bigutilsr)

zscores <- npyLoad("data/hpc/pcangsd/wa.pcadapt.zscores.npy")
galinsky <- npyLoad("data/hpc/pcangsd/wa.selection.npy")

sites_binary <- read_tsv("data/hpc/pcangsd/wa.sites",col_names = c("included"))
#d_scores <- dist_ogk(raw_scores)
K <- ncol(zscores)

# For one component only
if (K == 1) {
	d2 <- (zscores - median(zscores))^2
} else {
  # Calculates robus Mahalanobis (squared) distances
	d2 <- dist_ogk(zscores)
}

pvals <- pchisq(d2,df=K,lower.tail = F)
write_rds(pvals,"cache/pcadapt_pvals.rds")
```

For the first statistic (FastPCA / Galinsky statistic) we have one value for each of the PCs, whereas for pcadapt a single statistic based on robust Mahalanobis distance is used to summarise both PCs.  Examination of the distribution of p-values genome-wide in this case suggests that pcadapt is able to detect many significant loci under selection, whereas the Galinsky statistics are not.

```{r pca-score-histo}
score_data <- data.frame(galinsky,pcadapt_pval = pvals) %>% 
  mutate(galinsky_pc1 = pchisq(X1,df=1,lower.tail = F)) %>% 
  mutate(galinsky_pc2 = pchisq(X2,df=1,lower.tail = F)) %>% 
  select(-X1,-X2) %>% 
  pivot_longer(everything(),names_to = "name") %>% 
  slice_sample(n=100000)


ggplot(score_data) + geom_histogram(aes(x=value), binwidth = 0.01) + facet_wrap(~name, ncol = 1, scales = "free")
```

**Figure 2:** Histograms of raw p-values for selection statistics calculated by PCAngsd.

For the pcadapt statistic we create a Manhattan plot to view sites under selection across the genome.  Note that this uses Pseudo-chromosome level coordinates obtained via [RagTag](11.ragtag_scaffolding.md). This command converts coordinates into this pseudo-chromosome system

```bash
./translate_coords.py ../pcangsd/wa.positions.txt ragtag_output/ragtag.scaffolds.agp > ../pcangsd/wa.positions.scaf.txt
```

```{r pcadapt-manhattan-plot}

coordinates <- read_tsv("data/hpc/pcangsd/wa.positions.scaf.txt",col_names = c("scaffold","pos"))
coordinates_included <- coordinates[sites_binary$included==1,] %>% mutate(p=row_number())

lengths <- read_tsv("data/hpc/pcangsd/all.lengths.scaf.txt",col_names = c("scaffold","length"))
offsets <- lengths %>% arrange(desc(length)) %>% mutate(offset=cumsum(length)-length) %>% 
  mutate(scaffold_num = row_number())

manhattan_data <- coordinates_included %>% 
  left_join(offsets,by="scaffold") %>% 
  mutate(abs_pos = pos+offset) %>% 
  add_column(pval=-log10(pvals))

manhattan_data %>% 
  filter(pval>10) %>% 
  ggplot() + 
  geom_point(aes(x=abs_pos/1e6,y=pval,color=as.character(scaffold_num %% 2)),size=0.1) + ylab("-log10(p)") + xlab("Genome Position / Mb") + 
  geom_point(data = manhattan_data %>% filter(pval>200),aes(x=abs_pos/1e6,y=pval,color=as.character(scaffold_num %% 2)),size=2) + ylab("-log10(p)") + xlab("Genome Position / Mb") + 
    theme_pubclean() + theme(legend.position = "None")

write_rds(manhattan_data,file="cache/pcadapt.rds")
```


**Figure 3:** Manhattan plot showing the location of sites highly associated with population structure (-10log(p) > 10) across the genome






### Genome-wide Nucleotide diversity and Tajima\'s D

As a side note we observe that the genome-wide distributions of both pairwise nucleotide diversity and Tajima's D are extremely similar to those estimated from genotypes. 

```{r}
# Read in all the sliding window data.
#
all_thetas <- list.files("data/hpc/thetastat/",pattern = ".pestPG",full.names = TRUE) %>% 
  map_df(function(x){
    pop=basename(x) %>% str_extract("([^\\.]+)")
    read_tsv(x,col_types=cols()) %>% add_column(population=pop)
    }) %>% 
  rbind()
```


```{r td-pi-boxplot, fig.height=3.6}
library(cowplot)

pip <- ggplot(all_thetas,aes(x=population,y=tP/50000)) + 
  geom_boxplot(aes(fill=population)) + 
  xlab("") + ylab(expression(theta[pi]~"per bp")) + guides(fill=FALSE) + 
  scale_x_discrete(labels=c("Inshore","Offshore North","Offshore South")) +
  ggsci::scale_fill_startrek() + theme_classic() 

tdp <- ggplot(all_thetas,aes(x=population,y=Tajima)) + 
  geom_boxplot(aes(fill=population)) + 
  scale_x_discrete(labels=c("Inshore","Offshore North","Offshore South")) +
  xlab("") + ylab("Tajima's D") + guides(fill=FALSE) + ggsci::scale_fill_startrek() + theme_classic() 

plot_grid(pip,tdp,nrow=1, labels = c("A","B"))
```

**Figure 4**: Genome-wide distribution of pairwise nucleotide diversity (A) and Tajima's D (B) by population. 
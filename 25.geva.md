Dating allele emergence using GEVA
================

To investigate the timing of selection in relation to the emergence of
variants at selective sweeps we used
[GEVA](https://github.com/pkalbers/geva) (Albers and McVean 2020)
(Genealogical Estimation of Variant Age) to estimate the age of all 7.7M
variants genome-wide that were present within our sample of phased
haplotypes (see [03.phasing](03.phasing.md)).

One requirement for GEVA is that the ancestral and derived alleles are
identified for each SNP. We used
[est-sfs](http://www.homepages.ed.ac.uk/pkeightl//software) (Keightley
and Jackson 2018) for this task as follows;

First we created a whole-genome alignment of *A. digitifera* with two
outgroup species, *A. millepora* and *A. tenuis* using
[Cactus](https://github.com/ComparativeGenomicsToolkit/cactus) (v2.0.5).
We then exported the alleles at all snps using `halSnps` and then
filtered these to only include those overlapping our callset. These were
then used to generate an input file for `est-sfs` and to run `est-sfs`.
We then used `bcftools` and custom awk scripts to update our phased
variant callset by assigning the ancestral allele inferred by `est-sfs`
to the reference allele. This updating process takes care to update
genotypes in instances where ref and alt alleles are swapped from their
original values. See bash and shell scripts in
[data/hpc/ancestral\_allele/](data/hpc/ancestral_allele/) for details.

The phased vcf file with ref updated to the ancestral allele was then
used as input to GEVA. See [data/hpc/geva/](data/hpc/geva/) for details

## Variant consequence calling

Our ultimate goal was to investigate variance consequences in relation
to ages estimated by GEVA. Since we are interested in the consequences
of derived alleles we first created a version of the A. digitifera
genome in which the bases were altered at all SNP positions to be that
of the ancestral allele.

``` bash
# This uses bcftools to identify ref mismatches in the vcf with aa=ref
bcftools norm -c=w BLFC01000154.1_aaref.vcf.gz -f BLFC01000154.1.fasta 2> ref_mismatches.txt

# This creates a version of the ref with ancestral allele at SNP positions
cat ref_mismatches.txt | awk -f aaref.awk | bioawk -c fastx '{printf(">%s\n%s\n",$name,$seq)}' > BLFC01000154.1_aa.fasta

# Check that the new ref is correct
bcftools norm -c=x BLFC01000154.1_aaref.vcf.gz -f BLFC01000154.1_new.fasta
```

Consequence calling was then done using the vcf and reference sequences
where the AA is encoded as REF.

``` bash
bcftools csq -f BLFC01000154.1_aa.fasta -g s0150.g24.gff BLFC01000154.1_aaref.vcf.gz -O t > s0150.g24.csq.tsv 
```

We used results from GEVA in combination with allele frequency and
variant consequence information to investigate targeted loci in detail.

## Haem Peroxidase locus on BLFC01000154.1

``` bash
plink2 --vcf BLFC01000154.1_aaref.vcf.gz --allow-extra-chr --freq 'cols=chrom,pos,ref,alt,altfreq'  --pheno populations.txt --loop-cats 'site'
paste plink2.*.afreq | awk '{OFS="\t";print $1,$2,$4,$5,$6,$12,$18}' > BLFC01000154.1_plink2.all.afreq
```

``` bash
gunzip -c BLFC01000154.1_aaref.vcf.gz | grep -v '^#' | awk '{OFS="\t";print $1,$2,$4,$5,$8}' > BLFC01000154.1_aaref_allele_info.tsv
```

To understand the selected haplotype we examine variant consequences on
haps from inshore-only, and also exclude any inshore haps that cluster
with the offshore. There are three such inshore haps across two
individuals. We exclude both these individuals.

![](25.geva_files/figure-gfm/unnamed-chunk-6-1.png)<!-- -->

<div id="refs" class="references csl-bib-body hanging-indent">

<div id="ref-Albers2020-vl" class="csl-entry">

Albers, Patrick K, and Gil McVean. 2020. “Dating Genomic Variants and
Shared Ancestry in Population-Scale Sequencing Data.” *PLoS Biol.* 18
(1): e3000586.

</div>

<div id="ref-Keightley2018-dh" class="csl-entry">

Keightley, Peter D, and Benjamin C Jackson. 2018. “Inferring the
Probability of the Derived Vs. The Ancestral Allelic State at a
Polymorphic Site.” *Genetics* 209 (3): 897–906.

</div>

</div>

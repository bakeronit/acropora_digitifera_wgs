---
title: "05.demographic_history_msmc.Rmd"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.retina = 2)
library(tidyverse)
library(ggsci)
```

## MSMC analysis
For MSMC analysis, we restricted this analysis to high coverage (~20X) samples and used the maximum number of haplotypes (eight haplotypes) per population. To obtain more accurate phase information, all samples were used in initial variant calling using `bcftools` and conducting read aware phasing using `SHAPEIT2`.

```bash
bcftools mpileup -q 30 -Q 30 -C 50 -Oz -r $scaffold -f $reference.fa $(cat bamfile.txt | tr '\n' ' ') | \
bcftools call -c -V indels | bcftools view -M 2 -Oz > all.${scaffold}.vcf.gz

extractPIRs --bam ${scaffold}.bamlist --vcf all.${scaffold}.vcf.gz \
  --out ${scaffold}.PIRsList --base-quality 20 --read-quality 20

shapeit -assemble --input-vcf all.${scaffold}.vcf.gz --input-pir ${scaffold}.PIRsList -O $scaffold

shapeit -convert --input-haps $scaffold --output-vcf ${scaffold}.phased.vcf.gz

bcftools merge --force-samples all.${scaffold}.vcf.gz ${scaffold}.phased.vcf.gz |
awk 'BEGIN {{OFS="\t"}}
        $0 ~/^##/ {{print $0}}
$0 ~/^#CHROM/ {{for(i=1;i<84;i++) printf "%s"OFS, $i; print $84}}
$0 !~/^#/ {{ for(x=10;x<=84;x++) $x=$(x+75); for(j=1;j<84;j++) printf "%s"OFS, $j; print $84 }}' | \
bcftools view -Oz > final.${scaffold}.vcf.gz
```

For every sample, bamCaller.py was used to generate VCF file and mask file in bed format. `generate_multihetsep.py` was used to generate multihetsep files for every scaffold using all samples. A mappability mask file of the Acropora digitifera reference genome was generated following Heng Li’s [SNPable](http://lh3lh3.users.sourceforge.net/snpable.shtml).

```bash
$mean_cov=$(samtools depth -r $scaffold ${sample}.bam|awk '{sum += $3} END {print sum/NR}')

bcftools view -s $sample final.${scaffold}.vcf.gz |\
bamCaller.py $mean_cov ${sample}_${scaffold}_mask.bed.gz |gzip -c > ${sample}_${scaffold}.vcf.gz

generate_multihetsep.py --chr $scaffold --mask ${sample}_${scaffold}_mask.bed.gz \ 
--mask mappability/Adigi_${scaffold}.mask.bed.gz ${sample}_${scaffold}.vcf.gz > multihetsep_${scaffold}.txt
```

MSMC2 was firstly run for haplotypes from each population separately and calculate the cross-coalescence rate for each pair of two populations.To conduct bootstrap estimation, script multihetsep_bootstrap.py from msmc-tools was used to generate 100 sets of fragmented and resampled scaffolds by taking 20 random chunks per scaffold of size 500kb and assembling them into 20 “chromosomes”. Next, we conducted 100 bootstrap estimates for each population with 100 bootstrap data sets using the same options as before.

```bash
msmc2 -t 12 -s -I 0,1,2,3,4,5,6,7 -o inshore_8hap multihetsep_*.txt
msmc2 -t 12 -s -I 8,9,10,11,12,13,14,15 -o northoffshore_8hap multihetsep_*.txt
msmc2 -t 12 -s -I 16,17,18,19,20,21,22,23 -o southoffshore_8hap multihetsep_*.txt

multihetsep_bootstrap.py -n 100 -s 500000 —chunks_per_chromosome 20 \
 -nr_chromosomes 20 bootstrap *.multihetsep_*.txt

msmc2 -t 12 -s -I 0,1,2,3,4,5,6,7 -o bootstrap_results/inshore bootstrap_${n}/*.txt
msmc2 -t 12 -s -I 8,9,10,11,12,13,14,15 -o bootstrap_results/northoffshore bootstrap_${n}/*.txt
msmc2 -t 12 -s -I 16,17,18,19,20,21,22,23 -o bootstrap_results/southoffshore bootstrap_${n}/*.txt
```

```{r msmc-plot}
mu <- 1.2e-8 
inshore_8hap <- read.table("data/hpc/demography/msmc_out/inshore_8hap.final.txt", header=TRUE) %>% add_column(pop="inshore")
noffshore_8hap <-read.table("data/hpc/demography/msmc_out/northoffshore_8hap.final.txt", header=TRUE) %>% add_column(pop="northoffshore")
soffshore_8hap <-read.table("data/hpc/demography/msmc_out/southoffshore_8hap.final.txt", header=TRUE) %>% add_column(pop="soffshore")

df_8hap <- rbind(inshore_8hap,noffshore_8hap,soffshore_8hap)

ggplot(df_8hap) + geom_step(aes(x=left_time_boundary/mu*gen,y=(1/lambda)/2/mu,color=pop),size=0.8) +
  scale_x_log10() + scale_y_log10()

ybreaks2 <- 2e+4*seq(1,5,by=0.1)
ylabels2 <- as.character(ybreaks2)
ylabels2[!(ybreaks2%in%c(2e+4,4e+4,6e+4,8e+4,1e+5))] <- ''
ylabels2[ybreaks2%in%c(2e+4,4e+4,6e+4,8e+4,1e+5)] <- c("2","4","6","8","10")
ggplot(df_8hap)+ 
  scale_x_log10(breaks=xbreaks, labels=xlabels,limits=c(1e+3,1e+6)) + 
  geom_rect(data=dtime,aes(xmin=start,xmax=end,fill=name),ymin=-Inf, ymax=Inf,alpha=0.2,show.legend = FALSE) +
  scale_fill_manual(values = c("yellow","grey")) +
  geom_text(data=dtime, aes(x=(end-start)/4, label=name),y=1e+5, size=4,fontface="bold") +
  scale_y_continuous(breaks=ybreaks2,labels = ylabels2,limits = c(2e+4,1e+5)) +
  geom_step(aes(x=left_time_boundary/mu*gen,y=(1/lambda)/2/mu,color=pop),size=0.8) + 
  scale_color_startrek(labels=c("Inshore","North Offshore","South Offshore")) +
  #geom_step(data=bs_data_gbr_av, size=1,aes(color=pop)) +
  xlab(expression(paste("Years Ago (g=5, ",mu, "=1.2e-8)"))) + 
  ylab(expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")")))  + 
  theme_test() + theme(legend.title = element_blank(), legend.position = c(0.85,0.8))
```

**Figure:** The effective population size estimate MSMC.



> Here are some tips I had for using these two tools.
1. SMC++ doesn't need a phased vcf and can use more samples whereas to calculate the cross-coalescent rate, MSMC needs phased data.
2. To differentiate the homozygous blocks and missing data, both tools use mask file but the logic is contrast. In SMC++, mask file specific the regions as missing data which will be excluded in analysis, whereas in MSMC, the mask file represents the regions that are sufficiently covered by reads (--negative_mask means the same as SMC++). So, when you considering to use the mappability file in SMC++, it will give you wrong answer. 
I used bedtools to get the complement.

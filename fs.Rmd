---
title: "fineStructure"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

With phased vcf file, we performed chrmopainter and finestructure msmc and tree inferences.

The phased haps format files from shapeit were converted into chromopainter format with `impute2chromopainter.pl` per scaffold. To use linked mode, we generated uniform recombination rate map files using `makeuniformrecfile.pl`.

In chromopainter EM parameter estimate, we used 30% of samples (20) and estimated Ne and mu were used to run chromopainter. Next, fineStructure was run with 2000000 iterations of which half was assigned to burn in iteration and half to sampling iteration and -z 1000 as default. The sample relationship tree was built in step4 with 100,000 iterations.

```bash
fs adigitifera.cp -n -phasefiles phase_files/*.phase -recom/* \
-idfile samples.id -hpc 1 -s1indfrac 0.3 -s3iters 2000000 -go
cat adigitifera/commandfiles/commandfile1.txt | parallel -j 20

fs adigitifera.cp -go
cat adigitifera/commandfiles/commandfile2.txt | parallel -j 20

fs adigitifera.cp -go
cat adigitifera/commandfiles/commandfile3.txt | parallel -j 2

fs adigitifera.cp -go
cat adigitifera/commandfiles/commandfile4.txt | parallel -j 2

fs adigitifera.cp -go
fs fs -X -Y -e X2 adigitifera_linked.chunkcounts.out adigitifera_linked_tree.xml \
adigitifera_linked.mapstate.csv
fs fs -X -Y -e X2 adigitifera_linked.chunkcounts.out adigitifera_linked_mcmc.xml \
adigitifera_linked.meancoincidence.csv
```


```{r}
source("data/hpc/fineStructure/FinestructureRcode/FinestructureLibrary.R")

some.colors<-MakeColorYRP() # these are yellow-red-purple
some.colorsEnd<-MakeColorYRP(final=c(0.2,0.2,0.2)) # as above, but with a dark grey final for capped values

chunkfile<-"data/hpc/fineStructure/adigitifera_linked.chunkcounts.out" ## chromopainter chunkcounts file
mcmcfile<-"data/hpc/fineStructure/adigitifera_linked_mcmc.xml" ## finestructure mcmc file
treefile<-"data/hpc/fineStructure/adigitifera_linked_tree.xml" ## finestructure tree file
```

```{r}
###### READ IN THE CHUNKCOUNT FILE
dataraw<-as.matrix(read.table(chunkfile,row.names=1,header=T,skip=1)) # read in the pairwise coincidence 

###### READ IN THE MCMC FILES
mcmcxml<-xmlTreeParse(mcmcfile) ## read into xml format
mcmcdata<-as.data.frame.myres(mcmcxml) ## convert this into a data frame

###### READ IN THE TREE FILES

treexml<-xmlTreeParse(treefile) ## read the tree as xml format
ttree<-extractTree(treexml) ## extract the tree into ape's phylo format
## If you dont want to plot internal node labels (i.e. MCMC posterior assignment probabilities)
## now is a good time to remove them via:
#     ttree$node.label<-NULL
## Will will instead remove "perfect" node labels
ttree$node.label[ttree$node.label=="1"] <-""
## And reduce the amount of significant digits printed:
ttree$node.label[ttree$node.label!=""] <-format(as.numeric(ttree$node.label[ttree$node.label!=""]),digits=2)

tdend<-myapetodend(ttree,factor=1) # convert to dendrogram format



```


```{r}
pdf(file="data/hpc/fineStructure/FullDendrogram.pdf",height=6,width=14)
par(mar=c(6,0,2,0),mfrow=c(1,1))
plot(tdend,horiz=FALSE,nodePar=list(cex=0,lab.cex=0.6),edgePar=list(p.lwd=0.1,t.srt=90,t.off=-0.5),axes=F)
dev.off()
```



```{r}
## Now we work on the MAP state
mapstate<-extractValue(treexml,"Pop") # map state as a finestructure clustering
mapstatelist<-popAsList(mapstate) # .. and as a list of individuals in populations

popnames<-lapply(mapstatelist,NameSummary) # population names IN A REVERSIBLE FORMAT (I.E LOSSLESS)
## NOTE: if your population labels don't correspond to the format we used (NAME<number>) YOU MAY HAVE TROUBLE HERE. YOU MAY NEED TO RENAME THEM INTO THIS FORM AND DEFINE YOUR POPULATION NAMES IN popnamesplot BELOW
popnamesplot<-lapply(mapstatelist,NameMoreSummary) # a nicer summary of the populations
names(popnames)<-popnamesplot # for nicety only
names(popnamesplot)<-popnamesplot # for nicety only


popdend<-makemydend(tdend,mapstatelist) # use NameSummary to make popdend
popdend<-fixMidpointsComplete(popdend) # needed for obscure dendrogram reasons

popdendclear<-makemydend(tdend,mapstatelist,"NameMoreSummary")# use NameMoreSummary to make popdend
popdendclear<-fixMidpointsComplete(popdendclear) # needed for obscure dendrogram reasons

########################
## PLOT 2: population tree
pdf(file="data/hpc/fineStructure/PopulationDendrogram.pdf",height=6,width=12)
par(mar=c(8,2,2,2),cex=0.8)
plot(popdendclear,horiz=FALSE,nodePar=list(cex=0,lab.cex=1.2,las=2),edgePar=list(p.lwd=0.1,t.srt=0,t.off=0.3),yaxt="n",height=0.5,dLeaf=0.2)
dev.off()
```

```{r}
fullorder<-labels(tdend) # the order according to the tree
#mcmcmatrixraw<-as.matrix(read.csv(meancoincidencefile,row.names=1)) # read in the pairwise coincidence file we created earlier
#mcmcmatrix<-mcmcmatrixraw[fullorder,fullorder] 
#mapstatematrix<-groupingAsMatrix(mapstatelist)[fullorder,fullorder] # map state for reference


########################
## COANCESTRY MATRIX

datamatrix<-dataraw[fullorder,fullorder] # reorder the data matrix
```


```{r}
library(ComplexHeatmap)


Heatmap(datamatrix, cluster_rows = FALSE, cluster_columns = FALSE, show_row_names = FALSE, show_column_names = FALSE)

```



```{r}
tmatmax<-1200 # cap the heatmap
tmpmat<-datamatrix 
tmpmat[tmpmat>tmatmax]<-tmatmax # 
pdf(file="data/hpc/fineStructure/SimpleCoancestry.pdf",height=15,width=15)
plotFinestructure(tmpmat,dimnames(tmpmat)[[1]],dend=tdend,cols=some.colorsEnd,cex.axis=0.6,edgePar=list(p.lwd=0,t.srt=90,t.off=-0.1,t.cex=0.8))
dev.off()
```


```{r}
####################################
## PCA Principal Components Analysis
pcares<-mypca(dataraw)
# For figuring out how many PCs are important; see Lawson & Falush 2012
# You need packages GPArotation and paran
tmap<-optimalMap(dataraw)
thorn<-optimalHorn(dataraw)
c(tmap,thorn) # 11 and 5. Horn typically underestimates, Map is usually better
pcapops<-getPopIndices(rownames(dataraw),mapstatelist)
pcanames<-rownames(dataraw)
rcols<-rainbow(max(pcapops))

pdf("data/hpc/fineStructure/PCA.pdf",height=16,width=12)
par(mfrow=c(4,3))
for(i in 1:4) for(j in (i+1):5) {
  plot(pcares$vectors[,i],pcares$vectors[,j],col=rcols[pcapops],xlab=paste("PC",i),ylab=paste("PC",j),main=paste("PC",i,"vs",j),pch=rcols)
  text(pcares$vectors[,i],pcares$vectors[,j],labels=pcanames,col=rcols[pcapops],cex=0.5,pos=1)
}
dev.off()
```


**Figure:** Co-ancestry matrix with the tree showing inferred relationships between samples.
![img](figures/fs_co-ancestry_matrix.png)

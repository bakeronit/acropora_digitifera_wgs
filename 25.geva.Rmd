---
title: "Dating allele emergence using GEVA"
bibliography: bibliography.bib
output:
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE,message=FALSE,warning = FALSE)
library(tidyverse)
library(ggpubr)
library(cowplot)
```

To investigate the timing of selection in relation to the emergence of variants at selective sweeps we used [GEVA](https://github.com/pkalbers/geva) [@Albers2020-vl] (Genealogical Estimation of Variant Age) to estimate the age of variants at selected loci. 

One requirement for GEVA is that the ancestral and derived alleles are identified for each SNP. We used [est-sfs](http://www.homepages.ed.ac.uk/pkeightl//software) [@Keightley2018-dh] for this task as follows;
  
First we created a whole-genome alignment of *A. digitifera* with two outgroup species, *A. millepora* and *A. tenuis* using [Cactus](https://github.com/ComparativeGenomicsToolkit/cactus) (v2.0.5). We then exported the alleles at all snps using `halSnps` and filtered these to only include those overlapping our SNP callset. These were then used to generate an input file for `est-sfs`. 

After running `est-sfs` we used `bcftools` and custom awk scripts to update our phased variant callset by assigning the ancestral allele inferred by `est-sfs` to the reference allele.  This updating process takes care to update genotypes in instances where ref and alt alleles are swapped from their original values.  See bash and shell scripts in [data/hpc/ancestral_allele/](data/hpc/ancestral_allele/) for details.

The phased vcf file with ref updated to the ancestral allele was then used as input to GEVA. See [data/hpc/geva/](data/hpc/geva/) for details

## Variant consequence calling

We used `bcftools csq` to predict variance consequences for all SNPs overlapping the haem peroxidase gene `s0150.g24`.  Since we are interested in the consequences of derived alleles we first created a version of the *A. digitifera* genome in which the bases were altered at all SNP positions to be that of the ancestral allele.

```bash
# This uses bcftools to identify ref mismatches in the vcf with aa=ref
bcftools norm -c=w BLFC01000154.1_aaref.vcf.gz -f BLFC01000154.1.fasta 2> ref_mismatches.txt

# This creates a version of the ref with ancestral allele at SNP positions
cat ref_mismatches.txt | awk -f aaref.awk | bioawk -c fastx '{printf(">%s\n%s\n",$name,$seq)}' > BLFC01000154.1_aa.fasta

# Check that the new ref is correct
bcftools norm -c=x BLFC01000154.1_aaref.vcf.gz -f BLFC01000154.1_new.fasta
```

Consequence calling was then done using the vcf and reference sequences where the AA is encoded as REF.

```bash
bcftools csq -f BLFC01000154.1_aa.fasta -g s0150.g24.gff BLFC01000154.1_aaref.vcf.gz -O t > s0150.g24.csq.tsv 
```


## Haem Peroxidase locus on BLFC01000154.1

We used results from GEVA in combination with allele frequency and variant consequence information to investigate variants overlapping `s0150.g24` in detail.  
A plot of these allele frequencies by population indicates a large number of high-frequency derived alleles in the inshore population compared with the two offshore populations. This is expected since the inshore population was under selection.  Interestingly, when we break this down further we see that low frequency alleles in the inshore population are far younger than high frequency ones with the switch occurring between 2000 and 10000 generations ago. This strong dichotomy between young, rare alleles and old frequent ones is not present in the reference (offshore) populations. It suggests that most rare alleles in the inshore population reflect variants that have arisen since the onset of strong selection at this locus.

```{r}
if ( !file.exists("data/r_essentials/geva_pos.rds")){

  # Read allele age info from GEVA and join with physical position info
  sites_files <- list.files("data/hpc/geva/chroms/BLFC01000154.1/","*.sites",full.names = TRUE)

  options(readr.show_col_types = FALSE)
  geva_sites <- map_dfr(sites_files,read_table, col_types=cols())

  markers <- read_table("data/hpc/geva/chroms/BLFC01000154.1/BLFC01000154.1_geva.marker.txt")

  geva_pos <- geva_sites %>% 
    left_join(markers)
  write_rds(geva_pos,"data/r_essentials/geva_pos.rds")
} else {
  geva_pos <- read_rds("data/r_essentials/geva_pos.rds")
}

# Read haplotype-aware consequence info and join with geva_info
#
csq <- read_tsv("data/hpc/vcsq/s0150.g24.csq.tsv",col_names = c("CSQ","Sample","Hap","Chr","Position","Consequence"),skip = 4)

in_exclude_haps <- c("BR_5_121_S125_L004_1","BR_5_121_S125_L004_2","BR_5_123_S121_L004_1")

csq_pos <- csq %>% 
  left_join(geva_pos,by="Position") %>% 
  unite("Haplotype",Sample,Hap,sep = "_",remove = FALSE) %>% 
  extract(Consequence,into = "Category","([^\\|]*)",remove = FALSE) %>% 
  extract(Haplotype,into = "Location","([^_]*)",remove = FALSE) %>% 
  mutate(Category = case_when(
    Category=="intron" ~ "Non Coding",
    Category=="missense" ~ "Missense",
    Category=="splice_region" ~ "Splice Region",
    Category=="synonymous" ~ "Synonymous"
    )) %>% 
  ungroup() %>% 
  group_by(Position) %>% 
  mutate(total_haps=n_distinct(Haplotype)) #%>% 
#  filter(total_haps<140) # Remove SNPs with high frequency in both WA populations
```

Combining all this information we create the plot below

```{r}
n_inshore_haps <- 56
n_offshore_haps <- 89
sweep_age <- 8269.349

g24 <- read_tsv("data/hpc/vcsq/s0150.g24.mod.gff",col_names = c("Chr","Prog","feature_type","start","end")) 
  
g24_ex <- g24 %>% filter(feature_type=="exon")
g24_gene <- g24 %>% filter(feature_type=="gene")
g24_cds <- g24 %>% filter(feature_type=="CDS")


hap_based_af <- csq_pos %>% 
  ungroup() %>% 
  filter(between(Position,g24_gene$start,g24_gene$end)) %>% 
  filter(Clock=="J") %>% 
  filter(Filtered==1) %>% 
  mutate(selection_status = ifelse( (!(Haplotype %in% c("BR_5_121_S125_L004_1","BR_5_121_S125_L004_2","BR_5_123_S121_L004_1")) & (Location %in% c("BR","AI"))),"Selected","Background")) %>% 
  group_by(Position,Category,PostMedian) %>% 
  summarise(
    Selected = sum(selection_status=="Selected")/n_inshore_haps, 
    Background = sum(selection_status=="Background")/(n_offshore_haps+3),
    Age = PostMedian*5
    ) %>% 
  mutate(age_class = cut(Age,breaks=c(0,8000,Inf))) %>% 
  pivot_longer(cols=c("Selected","Background"), names_to = "haptype",values_to = "Freq") %>% 
  mutate(freq_class = cut(Freq,breaks=c(0,0.25,0.5,0.75,1.0))) %>% 
  distinct()

p_all <-  hap_based_af %>% 
  ggplot() + 
  geom_violin(aes(x=haptype,y=Freq,fill=haptype,color=haptype)) 

p_ac <- hap_based_af %>% 
  ggplot() + 
  geom_violin(aes(x=haptype,y=Freq,fill=haptype,color=haptype)) + 
#  geom_jitter(aes(x=haptype,y=Freq,color=haptype),height=0) + 
  facet_wrap(~age_class, nrow=1)

plot_grid(p_all,p_ac,ncol=1, labels = c("A","B"))
```

```{r}
hap_based_af %>% 
  ggplot() + 
  geom_violin(aes(x=haptype,y=Freq,fill=haptype,color=haptype)) + 
  facet_wrap(~age_class, nrow=1) + 
  theme_pubclean() + guides(fill="none",color="none") + 
  xlab("") + ylab("Allele Frequency")

ggsave("figures/fig-s20.png", width = 6.5,height = 4)

hap_based_af %>% 
  ungroup() %>% 
  dplyr::group_by(age_class,haptype) %>% 
  dplyr::summarise(count=n())
```


```{r}
library(colorspace)
cat_colors <- qualitative_hcl(4, palette = "Dark 2")
names(cat_colors) <- c("Missense","Non Coding","Splice Region","Synonymous")

csq_plot_data <- csq_pos %>% 
  filter(Clock=="J") %>% 
  filter(Filtered==1) %>% 
  group_by(Position) %>% 
  mutate(total_haps = n_distinct(Haplotype)) %>% 
  ungroup() %>% 
  mutate(selection_status = ifelse( (!(Haplotype %in% c("BR_5_121_S125_L004_1","BR_5_121_S125_L004_2","BR_5_123_S121_L004_1")) & (Location %in% c("BR","AI"))),"Selected","Background")) %>%
  mutate(selection_status_order = ifelse(selection_status=="Selected",1,2)) %>% 
  group_by(Position,selection_status) %>% 
  dplyr::summarise(Category,PostMedian,selection_status_order,total_haps,hap_count = n_distinct(Haplotype)) %>% 
  mutate(hap_freq = ifelse( selection_status=="Selected", hap_count/n_inshore_haps,hap_count/(n_offshore_haps+3))) %>% 
  distinct()

p_snps <- csq_plot_data %>%   
  filter(total_haps<=140) %>% # Remove SNPs that are nearly monomorphic (derived AF>95%)
  ggplot() + scale_y_log10(limits=c(5e3,NA)) +
  geom_linerange(data=g24_ex, aes(xmin=start,xmax=end,y=1e4),size=1000,color="grey",alpha=0.2) +  
  geom_point(aes(y=PostMedian*5,x=Position,color=Category,size=hap_freq),alpha=0.95) +
#  geom_point(aes(x=278594,y=6051*5),color="black",size=3) +
#  geom_point(aes(x=281245,y=6051*5),color="black",size=3) +
  facet_wrap(~reorder(selection_status,selection_status_order),ncol = 1,strip.position = "left") +
  scale_color_manual(values=cat_colors) +
  scale_size_area("Frequency",max_size = 3) +
  theme_pubclean() + theme(legend.position = "right") + 
  theme(strip.background = element_rect(fill = "transparent",color="black"), 
        axis.text.x = element_blank(), 
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.title.x = element_text(size=12),
        strip.text = element_text(size=12)) +
    ylab("Allele Age / Ybp") + 
  xlab("") + 
#  geom_hline(aes(yintercept=sweep_age,alpha=selection_status),size=0.5,color="black") +
  scale_alpha_manual(values=c(0,0.5)) + guides(alpha="none", fill="none") +
  xlim(275000,285000)

library(gggenes)
g24_sub <- g24 %>% 
  filter(feature_type %in% c("5'UTR","3'UTR", "CDS")) %>% 
  arrange(feature_type)



p_gene <- g24_gene %>% ggplot() +
  geom_gene_arrow(aes(y=Chr,xmin=start,xmax=end, forward = FALSE)) +
  geom_subgene_arrow(data=g24_sub,aes(xmin=275513,xmax=284565,xsubmin=start,xsubmax=end,y=Chr,fill=feature_type), forward=FALSE, alpha=0.9) +
    ylab("") + theme_genes() +
  xlim(275000,285000) + 
  theme(legend.position="bottom", 
        text = element_text(size=14), 
        axis.text.x = element_text(size=14),
#        strip.text = element_text(size=12),
        legend.title = element_blank())

legend <- get_legend(
  # create some space to the left of the legend
  p_snps + theme(legend.box.margin = margin(0, 0, 0, 12), legend.title = element_blank()) +
    theme(legend.position = "bottom", legend.key = element_blank())
)

pcol <- plot_grid(p_snps+ theme(legend.position="none"),
                  p_gene ,
                  ncol=1,
                  align = "v",axis="lr",
                  rel_heights = c(0.9,0.15))

ggsave(pcol,filename = "figures/allele_age.png",width = 10,height = 8)

#plot_grid(pcol,legend,nrow = 1,rel_widths = c(0.85,0.15))
ggsave(legend,filename = "figures/allele_age_legend.png",width = 8,height = 2)
```
```{r}
knitr::include_graphics("figures/allele_age.png")
```

An interesting feature of this plot is the very large number of missense variants in the second exon.  Let's count how many of these there are compared with the background

```{r}
csq_plot_data %>% filter(between(Position,282258,282894)) %>% group_by(selection_status,Category) %>% summarise(count=n_distinct(Position))
```



There are quite a few missense variants in the inshore copy. We can export the resulting protein sequence to see if there are any consequences of this change

```bash
bcftools view -S selected_indvs.txt BLFC01000154.1_aaref.vcf.gz > BLFC01000154.1_aaref_inshore.vcf
bgzip BLFC01000154.1_aaref_inshore.vcf 
tabix BLFC01000154.1_aaref_inshore.vcf.gz
bcftools consensus  -f BLFC01000154.1_aa.fasta BLFC01000154.1_aaref_inshore.vcf.gz > BLFC01000154.1_inshore_consensus.fasta
```

```bash
gffread -g BLFC01000154.1_inshore_consensus.fasta -y s0150.g24.protein_inshore.fa s0150.g24.gff
samtools faidx ../annotation/protein.fa adig_s0150.g24.t1 > s0150.g24.protein.fa 
```

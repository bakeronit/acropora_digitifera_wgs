---
title: "Dating allele emergence using GEVA"
bibliography: bibliography.bib
output:
  github_document:
    pandoc_args: --webtex
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE,message=FALSE,warning = FALSE)
library(tidyverse)
library(ggpubr)
library(cowplot)
```

To investigate the timing of selection in relation to the emergence of variants at selective sweeps we used [GEVA](https://github.com/pkalbers/geva) [@Albers2020-vl] (Genealogical Estimation of Variant Age) to estimate the age of all 7.7M variants genome-wide that were present within our sample of phased haplotypes (see [03.phasing](03.phasing.md)). 

One requirement for GEVA is that the ancestral and derived alleles are identified for each SNP. We used [est-sfs](http://www.homepages.ed.ac.uk/pkeightl//software) [@Keightley2018-dh] for this task as follows;
  
First we created a whole-genome alignment of *A. digitifera* with two outgroup species, *A. millepora* and *A. tenuis* using [Cactus](https://github.com/ComparativeGenomicsToolkit/cactus) (v2.0.5). We then exported the alleles at all snps using `halSnps` and filtered these to only include those overlapping our SNP callset. These were then used to generate an input file for `est-sfs`. 

After running `est-sfs` we used `bcftools` and custom awk scripts to update our phased variant callset by assigning the ancestral allele inferred by `est-sfs` to the reference allele.  This updating process takes care to update genotypes in instances where ref and alt alleles are swapped from their original values.  See bash and shell scripts in [data/hpc/ancestral_allele/](data/hpc/ancestral_allele/) for details.

The phased vcf file with ref updated to the ancestral allele was then used as input to GEVA. See [data/hpc/geva/](data/hpc/geva/) for details

## Variant consequence calling

We used `bcftools csq` to predict variance consequences for all SNPs overlapping the haem peroxidase gene `s0150.g24`.  Since we are interested in the consequences of derived alleles we first created a version of the *A. digitifera* genome in which the bases were altered at all SNP positions to be that of the ancestral allele.

```bash
# This uses bcftools to identify ref mismatches in the vcf with aa=ref
bcftools norm -c=w BLFC01000154.1_aaref.vcf.gz -f BLFC01000154.1.fasta 2> ref_mismatches.txt

# This creates a version of the ref with ancestral allele at SNP positions
cat ref_mismatches.txt | awk -f aaref.awk | bioawk -c fastx '{printf(">%s\n%s\n",$name,$seq)}' > BLFC01000154.1_aa.fasta

# Check that the new ref is correct
bcftools norm -c=x BLFC01000154.1_aaref.vcf.gz -f BLFC01000154.1_new.fasta
```

Consequence calling was then done using the vcf and reference sequences where the AA is encoded as REF.

```bash
bcftools csq -f BLFC01000154.1_aa.fasta -g s0150.g24.gff BLFC01000154.1_aaref.vcf.gz -O t > s0150.g24.csq.tsv 
```

We used results from GEVA in combination with allele frequency and variant consequence information to investigate variants overlapping `s0150.g24` in detail.

## Ferritin locus on BLFC01000600

```{r}
sites_files <- list.files("data/hpc/geva/chroms/BLFC01000600.1/","*.sites",full.names = TRUE)

options(readr.show_col_types = FALSE)
geva_sites <- map_dfr(sites_files,read_table, col_types=cols())

markers <- read_table("data/hpc/geva/chroms/BLFC01000600.1/BLFC01000600.1_geva.marker.txt")

geva_pos <- geva_sites %>% 
  left_join(markers)
```

```bash
plink2 --vcf BLFC01000154.1_aaref.vcf.gz --allow-extra-chr --freq 'cols=chrom,pos,ref,alt,altfreq'  --pheno populations.txt --loop-cats 'site'
paste plink2.*.afreq | awk '{OFS="\t";print $1,$2,$4,$5,$6,$12,$18}' > BLFC01000154.1_plink2.all.afreq
```

```{r}
allele_counts <- read_tsv("data/hpc/vcsq/BLFC01000600.1_plink2.all.afreq",col_names = c("CHROM","POS","REF","ALT","IN","NO","SO"),skip = 1) 

geva_info <- geva_pos %>% 
  left_join(allele_counts,by=c("Position"="POS"))

geva_info %>% 
  filter(dplyr::between(Position,3685540,3691260)) %>% 
  filter(PostMedian*5<2e4) %>% 
  group_by(MarkerID) %>% 
  summarise(PostMedian,IN,NO,SO) %>% 
  pivot_longer(cols=c("IN","NO","SO"), names_to = "Pop",values_to = "Freq") %>% 
  ggplot() + 
  geom_violin(aes(x=Pop,y=Freq,fill=Pop)) + 
  geom_point(aes(x=Pop,y=Freq,color=PostMedian),position="jitter") + 
  facet_wrap(~Pop)
```
```{r}
geva_info %>% 
  filter(dplyr::between(Position,3685540,3691260)) %>% 
  group_by(MarkerID,Position) %>% 
  summarise(PostMedian,IN,NO,SO) %>% 
  pivot_longer(cols=c("IN","NO","SO"), names_to = "Pop",values_to = "Freq") %>% 
  ggplot() + 
  geom_point(aes(x=Position,y=PostMedian*5,color=Freq)) + 
  facet_wrap(~Pop,ncol=1)
```


## Haem Peroxidase locus on BLFC01000154.1

```{r}
# Read allele age info from GEVA and join with physical position info
sites_files <- list.files("data/hpc/geva/chroms/BLFC01000154.1/","*.sites",full.names = TRUE)

options(readr.show_col_types = FALSE)
geva_sites <- map_dfr(sites_files,read_table, col_types=cols())

markers <- read_table("data/hpc/geva/chroms/BLFC01000154.1/BLFC01000154.1_geva.marker.txt")

geva_pos <- geva_sites %>% 
  left_join(markers)
```


```bash
plink2 --vcf BLFC01000154.1_aaref.vcf.gz --allow-extra-chr --freq 'cols=chrom,pos,ref,alt,altfreq'  --pheno populations.txt --loop-cats 'site'
paste plink2.*.afreq | awk '{OFS="\t";print $1,$2,$4,$5,$6,$12,$18}' > BLFC01000154.1_plink2.all.afreq
```

```bash
gunzip -c BLFC01000154.1_aaref.vcf.gz | grep -v '^#' | awk '{OFS="\t";print $1,$2,$4,$5,$8}' > BLFC01000154.1_aaref_allele_info.tsv
```

```{r}
# Read allele frequencies from PLINK and join with geva ages
#
allele_counts <- read_tsv("data/hpc/vcsq/BLFC01000154.1_plink2.all.afreq",col_names = c("CHROM","POS","REF","ALT","IN","NO","SO"),skip = 1) 

geva_info <- geva_pos %>% 
  left_join(allele_counts,by=c("Position"="POS"))

geva_info %>% 
  filter(dplyr::between(Position,265513,294565)) %>% 
  group_by(MarkerID) %>% 
  summarise(IN,NO,SO) %>% 
  pivot_longer(cols=c("IN","NO","SO"), names_to = "Pop",values_to = "Freq") %>% 
  ggplot() + geom_density(aes(x=Freq,fill=Pop)) + facet_wrap(~Pop)


geva_info %>% 
  filter(dplyr::between(Position,265513,294565)) %>% 
#  filter(PostMedian*5<2e4) %>% 
  group_by(MarkerID) %>% 
  summarise(PostMedian,IN,NO,SO) %>% 
  pivot_longer(cols=c("IN","NO","SO"), names_to = "Pop",values_to = "Freq") %>% 
  ggplot() + 
  geom_point(aes(x=Pop,y=Freq,color=PostMedian),position="jitter") + 
  geom_violin(aes(x=Pop,y=Freq,fill=Pop),alpha=0.5) + 
  facet_wrap(~Pop)
```


```{r}
# Read haplotype-aware consequence info and join with geva_info
#
csq <- read_tsv("data/hpc/vcsq/s0150.g24.csq.tsv",col_names = c("CSQ","Sample","Hap","Chr","Position","Consequence"),skip = 4)

csq_pos <- geva_info %>% 
  left_join(csq,by="Position") %>% 
  unite("Haplotype",Sample,Hap,sep = "_",remove = FALSE) %>% 
  extract(Consequence,into = "Category","([^\\|]*)",remove = FALSE) %>% 
  extract(Haplotype,into = "Location","([^_]*)",remove = FALSE) %>% 
  mutate(Category = case_when(
    Category=="intron" ~ "Non Coding",
    Category=="missense" ~ "Missense",
    Category=="splice_region" ~ "Splice Region",
    Category=="synonymous" ~ "Synonymous"
    ))
```


To understand the selected haplotype we examine variant consequences on haps from inshore-only, and also exclude any inshore haps that cluster with the offshore. 
There are three such inshore haps across two individuals. We exclude both these individuals. 

```{r}
in_exclude_samples <- c("BR_5_123_S121_L004","BR_5_121_S125_L004")
in_exclude_haps <- c("BR_5_121_S125_L004_1","BR_5_121_S125_L004_2","BR_5_123_S121_L004_1")

n_inshore_haps <- 56
n_offshore_haps <- 89

csq_pos_in <- csq_pos %>% 
  filter(Clock=="J") %>% 
  filter(Filtered==1) %>% 
  filter(Location %in% c("BR","AI")) %>% 
  filter(!(Haplotype %in% in_exclude_haps)) %>% 
  group_by(Position,ALT) %>% 
  mutate(HAP_COUNT=n_distinct(Haplotype)) %>% 
  mutate(hap_freq=HAP_COUNT/n_inshore_haps)
  

csq_pos_off <- csq_pos %>% 
  filter(Clock=="J") %>% 
  filter(Filtered==1) %>% 
  filter(!(Location %in% c("BR","AI"))) %>% 
  group_by(Position,ALT) %>% 
  mutate(HAP_COUNT=n_distinct(Haplotype)) %>% 
  mutate(hap_freq = HAP_COUNT/n_offshore_haps)

csq_pos_both <- csq_pos %>% 
  ungroup() %>% 
  filter(between(Position,275513,284565)) %>% 
  filter(Clock=="J") %>% 
  filter(Filtered==1) %>% 
  mutate(selection_status = ifelse( !(Haplotype %in% c("BR_5_121_S125_L004_1","BR_5_121_S125_L004_2","BR_5_123_S121_L004_1")),"selected","background")) %>% 
  group_by(Position,ALT,Category,PostMedian) %>% 
  summarise(sel_count = sum(selection_status=="selected"), anc_count = sum(selection_status=="background"))
  

```



```{r}
g24 <- read_tsv("data/hpc/vcsq/s0150.g24.mod.gff",col_names = c("Chr","Prog","feature_type","start","end")) 
  
g24_ex <- g24 %>% filter(feature_type=="exon")
g24_gene <- g24 %>% filter(feature_type=="gene")
g24_cds <- g24 %>% filter(feature_type=="CDS")

dp <- csq_pos_both %>% 
  mutate(x=Position,y=PostMedian*5, sel=as.numeric(sel_count),anc=as.numeric(anc_count)) %>% 
  select(x,y,Category,sel,anc) #%>% 
#  pivot_longer(cols=c("sel","anc"),names_to = "pop",values_to = "hap_count") %>% 
  

# library(scatterpie)
# ggplot() +
# geom_scatterpie(aes(y=y/300,x=x,group=Category,radius=0.1),data=dp,cols=c("sel","anc")) 
#  ggplot() + geom_point(aes(y=PostMedian*5,x=Position,color=Category))
```


```{r}
p_in <- csq_pos_in %>% 
  mutate(hap_freq=HAP_COUNT/n_inshore_haps) %>% 
  filter(!is.na(Consequence)) %>% 
  ggplot() + scale_y_log10(limits=c(5e3,NA)) +
  geom_linerange(data=g24_ex, aes(xmin=start,xmax=end,y=1e4),size=1000,color="yellow",alpha=0.2) +  
  geom_point(aes(y=PostMedian*5,x=Position,color=Category,size=hap_freq)) +
  scale_size_area("Frequency",max_size = 3) +
  theme_pubclean() + theme(legend.position = "right") +
    ylab("Allele Age (years before present)") + 
  xlab("") + 
  geom_hline(aes(yintercept=1e4)) + 
  xlim(275000,285000)

p_off <- csq_pos_off %>% 
  mutate(hap_freq=HAP_COUNT/n_inshore_haps) %>% 
  filter(!is.na(Consequence)) %>% 
  ggplot() + scale_y_log10(limits=c(5e3,NA)) +
  geom_linerange(data=g24_ex, aes(xmin=start,xmax=end,y=1e4),size=1000,color="yellow",alpha=0.2) +  
  geom_point(aes(y=PostMedian*5,x=Position,color=Category,size=hap_freq)) +
  scale_size_area(max_size = 3) +
  theme_pubclean() +
    ylab("Allele Age (years before present)") + 
  xlab("") + 
  xlim(275000,285000)

library(gggenes)
g24_sub <- g24 %>% 
  filter(feature_type %in% c("5'UTR","3'UTR", "CDS")) %>% 
  arrange(feature_type)



p_gene <- g24_gene %>% ggplot() +
  geom_gene_arrow(aes(y=Chr,xmin=start,xmax=end, forward = FALSE)) +
  geom_subgene_arrow(data=g24_sub,aes(xmin=275513,xmax=284565,xsubmin=start,xsubmax=end,y=Chr,fill=feature_type), forward=FALSE, alpha=0.5) +
    ylab("") + theme_genes() +
  xlim(275000,285000) + theme(legend.position="bottom", legend.title = element_blank())

legend <- get_legend(
  # create some space to the left of the legend
  p_in + theme(legend.box.margin = margin(0, 0, 0, 12))
)

prow <- plot_grid(p_in+ theme(legend.position="none"),
                  p_off+ theme(legend.position="none"),
                  p_gene ,
                  ncol=1,
                  align = "v",
                  rel_heights = c(0.45,0.45,0.3))

plot_grid(prow,legend,nrow = 1,rel_widths = c(0.85,0.15))
ggsave("figures/allele_age.png",width = 10,height = 8)
```
There are quite a few missense variants in the inshore copy. We can export the resulting protein sequence to see if there are any consequences of this change

```bash
bcftools view -S selected_indvs.txt BLFC01000154.1_aaref.vcf.gz > BLFC01000154.1_aaref_inshore.vcf
bgzip BLFC01000154.1_aaref_inshore.vcf 
tabix BLFC01000154.1_aaref_inshore.vcf.gz
bcftools consensus  -f BLFC01000154.1_aa.fasta BLFC01000154.1_aaref_inshore.vcf.gz > BLFC01000154.1_inshore_consensus.fasta
```

```bash
gffread -g BLFC01000154.1_inshore_consensus.fasta -y s0150.g24.protein_inshore.fa s0150.g24.gff
samtools faidx ../annotation/protein.fa adig_s0150.g24.t1 > s0150.g24.protein.fa 
```

---
title: "Demographic history - Sequentially Markov Cross-coalescence analysis"
output: 
  github_document:
    toc: TRUE
    toc_depth: 3
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.retina = 2)
library(tidyverse)
library(ggsci)
```

## SNP data for Sequentially Markovian Coalescent (SMC) analyses
We only used variations from scaffolds with a length greater than the N50 in [demography analyses], moreover, phased data in MSMC analysis. 

Specifically, we used:

- three individuals from each location in **PSMC analysis**.
- eight haplotypes (4 samples) from each reef in **MSMC**.
- All samples (unphased) except the mis-located sample from each location in **SMC++**.


For both SMC++ and MSMC, we used SNPs from scaffolds with a length greater than 1Mbp which account for approximately 75% of genome size (N75=983,972, first 142 scaffolds). 

## 1. Mutation rate estimate
The per generation mutation rate of *A.digitifera* estimated based on a divergence time of 15.5 Millions years is 2.89e-8 in [@Mao2018]. However, the divergence time in [@Shinzato2020] is 25-50 million years which give us a much smaller per generation mutation rate of 1.2e-8.

```bash
#(79427941/(79427942+363368171)/(2 × 15.5)) x 5 × 10−6 = 2.89 × 10−8
#calibrate divergence time to 37.5
(79427941/(79427942+363368171)/(2 × 37.5)) x 5 × 10−6 = 1.20 x 10-8
```

## 2. SMC++ analysis
 
We used SNP data of 74 samples (except one mislocated samples from inshore) in SMC++ analyses. Firstly, a single VCF file with variants of samples was extracted for every scaffold and indexed.

```bash
bcftools view -r {chr} -Oz -o {chr}.vcf.gz Adigi.v2.filtered.vcf.gz 
tabix {chr}.vcf.gz
```
To distinguish invariant positions with missing data, we mask genome regions a) with low or super high coverage across all samples (less than three reads covered or greater than 3000) b) We generated the genome mask files created using Heng Li's SNPable tools and extracted the ambiguous positions (c=="0" or c=="1").

```bash
samtools depth -r {chr} -aa -f bamfiles.txt | \
awk '{sum=0; for(i=3; i<=NF; i++) {sum+=$i}; print $1"\t"$2"\t"sum }' | \
awk '{if($3<3 || $3>3000) print $1"\t"$2"\t"$2}' | \
bedtools merge -i stdin | bgzip > {chr}.low_masked.bed.gz

zcat {chr}.low_masked.bed.gz Adigi_{chr}.mask.bed.gz | bedtools sort | bedtools merge |bgzip > {chr}.masked.bed.gz
```
Mask files of all scaffolds were concatenated together and we keep blocks with a length greater than 2kb. Next, vcf files were converted into a smc format file using `vcf2smc` in which we send a vcf file of one scaffold and specify a list samples in the population.

```bash
smc++ vcf2smc --mask all.masked.bed.gz {chr}.vcf.gz {pop}.{chr}.smc.gz {chr} POP:{sampleid},..
```
smc++ `estimate` mode was run to fit population size history to data for each population.

### 2.1 Demographic history of three reefs

```bash
smc++ estimate --cores 30 -o estimate --base {pop} --spline cubic \
 --timepoints 20 200000 --em-iterations 50 --thinning 3000 --knots 10 1.2e-8 {pop}.*.smc.gz
```

```{r plot-seting}
mu <- 1.2e-8 
gen <- 5
dtime = data.frame(name=c("LGM","Holocene"), start=c(1.2e+4,0), end=c(1.1e+5,1.2e+4))
smc <- read_csv("data/hpc/demography/estimate_em50_cubic_k10/em50_cubic_k10.csv")

xbreaks <- c(1e+2*1:9, 1e+3*1:9 , 1e+4*1:9 , 1e+5*1:9 , 1e+6*1:9 , 1e+7)
xlabels <- as.character(xbreaks)
xlabels[!(xbreaks%in%c(1e+3,1e+4,1e+5,1e+6,1e+7))] <- ''
xlabels[xbreaks%in%c(1e+3,1e+4,1e+5,1e+6,1e+7)] <-c("1kya","10kya","100kya","1mya","10mya")

ybreaks <- c(1e+3*2:9 , 1e+4*1:9 , 1e+5*1:9 , 1e+6*1:2)
ylabels <- as.character(ybreaks)
ylabels[!(ybreaks%in%c(1e+4,1e+5,1e+6))] <- ''
ylabels[ybreaks%in%c(1e+4,1e+5,1e+6)] <- c("1","10","100")
```

```{r smc-plot, fig.align='center',fig.width=7,fig.height=5, fig.cap="Figure1: The effective population size estimate using SMC++ approach. The red, blue, and green lines represent the results of inshore, offshore north, and offshore south respectively."}
ggplot(smc) + geom_line(aes(x=x,y=y,color=label),size=0.8,show.legend = FALSE) +
  geom_rect(data=dtime,aes(xmin=start,xmax=end,fill=name),ymin=-Inf, ymax=Inf,alpha=0.2,show.legend = FALSE) + 
  scale_fill_manual(values = c("yellow","grey")) +
  geom_text(data=dtime, aes(x=c(3e+4,2e+3),y=2e+6,label=name), size=4, fontface="bold") +
  scale_x_log10(breaks=xbreaks, labels=xlabels)+
  scale_y_log10(breaks=ybreaks,labels=ylabels,limits=c(2e+3,2e+6)) + 
  scale_color_startrek() + theme_test() + 
  labs(x=expression(paste("Years Ago (g=5, ",mu, "=1.20e-8)")),
  y=expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")"))) +
  ggtitle("Historial effective population size estimated by SMC++")
```

### 2.2 Divergence time among populations

The smc++ can estimate joint demography and speculate the splitting time between pair of populations. First, we create a joint frequency spectrum for every pair of populations using `vcf2smc`.

```bash
smc++ vcf2smc {chr}.vcf.gz {pop1}_{pop2}.smc.gz {chr} POP1:{sampleid},..  POP2:{sampleid},..
```

Next,we ran smc++ `split` with same parameters we used in `estimate`.

```bash
smc++ split -o split --base {pop1}_{pop2} \
--timepoints 20 200000 --em-iterations 50 --thinning 3000 \
{pop1}.final.json {pop2}.final.json {pop1}_{pop2}.smc.gz
```

```{r split, fig.show="hold", out.width="33%"}
library(png)
library(knitr)
split_plot <- list.files(path = "figures/",pattern = "*.split.png" ,full.names = TRUE)
include_graphics(split_plot)
```

**Figure 2: Three figures above show the joint demography between any two populations  (IN: Inshore, NO: North Offshore, SO: South Offshore) and the estimated splitting time (blue vertical line)**


### 2.3 Bootstrap estimate

We perform 20 bootstrap estimates in SMC++ with fragmented and re-sampled scaffolds. SMC++ was run with these data sets with the same parameters as before.

```{r}
smc_main <- read_csv("data/hpc/demography/estimate_em50_k40/em50_k40.csv") %>% select(label,x,y) %>% add_column(type="main")
read_bootstrap <- function(pop, n) {
  read_csv(paste0("data/hpc/demography/smc_bootstrap/",pop,"_",n,".csv" )) %>% select(label,x,y) %>% add_column(n=paste0("bs",n))
}

smc_bs <- rbind(map_df(1:20, ~read_bootstrap(pop="inshore",n=.x)),
                map_df(1:20, ~read_bootstrap(pop="northoffshore",n=.x)),
                map_df(1:20, ~read_bootstrap(pop="southoffshore",n=.x)))

```

```{r bootstrap-plot}

smc_bootstrap_plot <- ggplot() + geom_line(data=smc_main,aes(x=x,y=y,color=label),size=1,show.legend = FALSE) +
  geom_line(data = smc_bs, aes(x=x,y=y,color=label,group=interaction(label,n)),alpha=0.1,show.legend = FALSE)+
  scale_x_log10(breaks=xbreaks, labels=xlabels)+
  scale_y_log10(breaks=ybreaks,labels=ylabels,limits=c(2e+3,2e+6)) + 
  scale_color_startrek() + theme_test() + 
  labs(x=expression(paste("Years Ago (g=5, ",mu, "=1.20e-8)")),
  y=expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")"))) 
  # + ggtitle("Historical effective population size estimated by SMC++ with 20 bootstraps")
smc_bootstrap_plot
```

**Figure 3: Historical effective population size estimated by SMC++ with 20 bootstraps**

## 3. MSMC analysis

We also used MSMC to infer the demographic history in which we restricted this analysis to high coverage (~20X) samples and used the maximum number of haplotypes (eight haplotypes) per population. To obtain more accurate phase information, all samples were used in initial variant calling using `bcftools` and conducting read aware phasing using `SHAPEIT2`.

```bash
bcftools mpileup -q 30 -Q 30 -C 50 -Oz -r $scaffold -f $reference.fa $(cat bamfile.txt | tr '\n' ' ') | \
bcftools call -c -V indels | bcftools view -M 2 -Oz > all.${scaffold}.vcf.gz

extractPIRs --bam ${scaffold}.bamlist --vcf all.${scaffold}.vcf.gz \
  --out ${scaffold}.PIRsList --base-quality 20 --read-quality 20

shapeit -assemble --input-vcf all.${scaffold}.vcf.gz --input-pir ${scaffold}.PIRsList -O $scaffold

shapeit -convert --input-haps $scaffold --output-vcf ${scaffold}.phased.vcf.gz

bcftools merge --force-samples all.${scaffold}.vcf.gz ${scaffold}.phased.vcf.gz |
awk 'BEGIN {{OFS="\t"}}
        $0 ~/^##/ {{print $0}}
$0 ~/^#CHROM/ {{for(i=1;i<84;i++) printf "%s"OFS, $i; print $84}}
$0 !~/^#/ {{ for(x=10;x<=84;x++) $x=$(x+75); for(j=1;j<84;j++) printf "%s"OFS, $j; print $84 }}' | \
bcftools view -Oz > final.${scaffold}.vcf.gz
```

For every sample, bamCaller.py was used to generate VCF file and mask file in bed format. `generate_multihetsep.py` was used to generate multihetsep files for every scaffold using all samples. A mappability mask file of the Acropora digitifera reference genome was generated following Heng Li’s [SNPable](http://lh3lh3.users.sourceforge.net/snpable.shtml).

```bash
$mean_cov=$(samtools depth -r $scaffold ${sample}.bam|awk '{sum += $3} END {print sum/NR}')

bcftools view -s $sample final.${scaffold}.vcf.gz |\
bamCaller.py $mean_cov ${sample}_${scaffold}_mask.bed.gz |gzip -c > ${sample}_${scaffold}.vcf.gz

generate_multihetsep.py --chr $scaffold --mask ${sample}_${scaffold}_mask.bed.gz \ 
--mask mappability/Adigi_${scaffold}.mask.bed.gz ${sample}_${scaffold}.vcf.gz > multihetsep_${scaffold}.txt
```

MSMC2 was firstly ran for haplotypes from each population separately and then calculated the cross-coalescence rate for each pair of two populations.To conduct bootstrap estimation, script multihetsep_bootstrap.py from msmc-tools was used to generate 100 sets of fragmented and resampled scaffolds by taking 20 random chunks per scaffold of size 500kb and assembling them into 20 “chromosomes”. Next, we conducted 100 bootstrap estimates for each population with 100 bootstrap data sets using the same options as before.

```bash
msmc2 -t 12 -s -I 0,1,2,3,4,5,6,7 -o inshore_8hap multihetsep_*.txt
msmc2 -t 12 -s -I 8,9,10,11,12,13,14,15 -o northoffshore_8hap multihetsep_*.txt
msmc2 -t 12 -s -I 16,17,18,19,20,21,22,23 -o southoffshore_8hap multihetsep_*.txt

multihetsep_bootstrap.py -n 100 -s 500000 —chunks_per_chromosome 20 \
 -nr_chromosomes 20 bootstrap *.multihetsep_*.txt

msmc2 -t 12 -s -I 0,1,2,3,4,5,6,7 -o bootstrap_results/inshore bootstrap_${n}/*.txt
msmc2 -t 12 -s -I 8,9,10,11,12,13,14,15 -o bootstrap_results/northoffshore bootstrap_${n}/*.txt
msmc2 -t 12 -s -I 16,17,18,19,20,21,22,23 -o bootstrap_results/southoffshore bootstrap_${n}/*.txt
```

```{r msmc-plot}
gen <- 5
mu <- 1.2e-8 

#inshore_8hap <- read.table("data/hpc/demography/msmc_out/inshore_8hap.final.txt", header=TRUE) %>% add_column(pop="inshore")
#noffshore_8hap <-read.table("data/hpc/demography/msmc_out/northoffshore_8hap.final.txt", header=TRUE) %>% add_column(pop="northoffshore")
#soffshore_8hap <-read.table("data/hpc/demography/msmc_out/southoffshore_8hap.final.txt", header=TRUE) %>% add_column(pop="soffshore")
inshore_8hap <- read.table("~/Dropbox/PhD/Chapters/Chapter I/demographic/msmc/final/inshore_8hap.final.txt", header=TRUE) %>% add_column(pop="inshore")
noffshore_8hap <-read.table("~/Dropbox/PhD/Chapters/Chapter I/demographic/msmc/final/noffshore_8hap.final.txt", header=TRUE) %>% add_column(pop="northoffshore")
soffshore_8hap <-read.table("~/Dropbox/PhD/Chapters/Chapter I/demographic/msmc/final/soffshore_8hap.final.txt", header=TRUE) %>% add_column(pop="soffshore")

df_8hap <- rbind(inshore_8hap,noffshore_8hap,soffshore_8hap)

# read_msmc_bs <- function(pop, basedir="data/hpc/demography/msmc_out/bootstrap_results") {
#   bs_files <- list.files(basedir, paste0("msmc_",pop,"_bs_",".*.final.txt"), full.names = TRUE)
#   data <- map_df(bs_files,function(fn) {
#     read_tsv(fn) %>% add_column(pop=pop, bn=gsub(".*_(\\d+)\\.final\\.txt","\\1",x = fn)) %>% unite(bsid,bn,pop,remove = FALSE)
#   })
#   data
# }
# 
# bs_in_data <- read_msmc_bs("in")
# bs_no_data <- read_msmc_bs("no")
# bs_so_data <- read_msmc_bs("so")
# 
# bs_data <- rbind(bs_in_data,bs_no_data,bs_so_data)
# bs_data_av <- bs_data %>% group_by(pop,time_index) %>% summarise(left_time_boundary=mean(left_time_boundary),right_time_boundary=mean(right_time_boundary),lambda=mean(lambda))
#ymax <- bs_data_av %>% mutate(y=(1/lambda)/2/mu) %>% pull(y) %>% max()
#ymin <- bs_data_av %>% mutate(y=(1/lambda)/2/mu) %>% pull(y) %>% min()

# ggplot(bs_data,aes(x=left_time_boundary/mu*gen,y=(1/lambda)/2/mu)) + 
#   scale_x_log10(breaks=c(1e+4,1e+5,1e+6,1e+7), labels=c("10kya","100kya","1mya","10mya")) +
#   #geom_step(aes(group=bsid,color=pop),alpha=0.04,size=1) +
#   geom_step(data=bs_data_av, size=1,aes(color=pop))  +
#   ylim(ymin,1.8e+5)+
#   xlab("Years Ago") + 
#   ylab(expression(paste("Effective Population Size ",N[e]))) + 
#   theme_minimal() + theme(legend.title = element_blank(), legend.position = c(0.8,0.8)) + 
#   theme(text=element_text(size=20), legend.title = element_blank())


ybreaks2 <- 3e+4*seq(1,5,by=0.1)
ylabels2 <- as.character(ybreaks2)
ylabels2[!(ybreaks2%in%c(3e+4,6e+4,9e+4,1.2e+5,1.5e+5))] <- ''
ylabels2[ybreaks2%in%c(2e+4,4e+4,6e+4,8e+4,1e+5)] <- c("2","4","6","8","10")

ggplot(df_8hap)+ 
  scale_x_log10(breaks=c(1e+3,1e+4,1e+5,1e+6,1e+7), labels=c("1kya","10kya","100kya","1mya","10mya"), limits=c(1e3,3e6)) + 
  #geom_rect(data=dtime,aes(xmin=start,xmax=end,fill=name),ymin=-Inf, ymax=Inf,alpha=0.2,show.legend = FALSE) +
  #scale_fill_manual(values = c("yellow","grey")) +
  #geom_text(data=dtime, aes(x=(end-start)/4, label=name),y=1e+5, size=4,fontface="bold") +
  scale_y_log10(limits = c(5e+4,10000000)) +
  geom_step(aes(x=left_time_boundary/mu*gen,y=(1/lambda)/2/mu,color=pop),size=0.8) + 
  scale_color_startrek(labels=c("Inshore","North Offshore","South Offshore")) +
  #geom_step(data=bs_data_gbr_av, size=1,aes(color=pop)) +
  xlab(expression(paste("Years Ago (g=5, ",mu, "=1.20e-8)"))) + 
  ylab(expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")")))  + 
  theme_test() + theme(legend.title = element_blank(), legend.position = c(0.85,0.85))
```

**Figure 4: Demographic history infered by MSMC**

## Add climate data in plot
```{r}
climate_data <- read_tsv("data/hpc/demography/nature07158-s2.txt",skip = 14)
library(cowplot)
fn <-list.files(path="data/hpc/demography/psmc/psmc_plot_temp", pattern = "final_bp.*.txt",full.names = T)
  #ggplot(aes(x=X1,y=X2)) + geom_step()+ scale_x_log10()
read_single_psmc <- function(.x) {
  bs_n <- gsub("data/hpc/demography/psmc/psmc_plot_temp/final_bp.(\\d+).txt","\\1",.x) %>% as.integer()
  print(bs_n)
  pop <- case_when(bs_n<=100~"inshore", bs_n>100 && bs_n<=201 ~ "northoffshore", bs_n>=202~"southoffshore")
  print(pop)
  tb<-read_tsv(.x,col_names = F) %>% select(X1,X2) %>% add_column(pop=pop,bs_n=bs_n)
  tb
}

df <- map_df(.x=fn, .f = read_single_psmc)

psmc_plot<-ggplot(df,aes(x=X1,y=X2,group=bs_n)) + geom_step(aes(color=pop),alpha=0.3) + geom_step(data=df %>% filter(bs_n %in% c(0,101,202)), color="black", size=.8) +
  scale_x_log10(breaks=c(1e+4,1e+5,1e+6,1e+7), labels=c("10kya","100kya","1mya","10mya"), limits=c(1e4,3e6)) +
  scale_color_startrek(guide=F) + theme_test() + labs(x="",y="")



smc_plot <- ggplot() + geom_line(data=smc_main,aes(x=x,y=y,color=label),size=1,show.legend = FALSE) +
  geom_line(data = smc_bs, aes(x=x,y=y,color=label,group=interaction(label,n)),alpha=0.1,show.legend = FALSE)+
  scale_x_log10(breaks=c(1e+4,1e+5,1e+6,1e+7), labels=c("10kya","100kya","1mya","10mya"), limits=c(1e4,3e6))+
  scale_y_log10(breaks=ybreaks,labels=ylabels,limits=c(2e+3,2e+6)) + 
  scale_color_startrek() + theme_test() + 
  labs(x=expression(paste("Years Ago (g=5, ",mu, "=1.20e-8)")),
  y=expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")"))) 

cp <- ggplot(climate_data %>% filter(Time>1),aes(x=Time*1e3,y=-Ice_tot)) + 
  geom_line() + 
  scale_x_log10(breaks=c(1e+4,1e+5,1e+6,1e+7), labels=c("10kya","100kya","1mya","10mya"), limits=c(1e4,3e6)) +
  theme_minimal() +
  ylab("Sea Level") + xlab("Years Ago")
plot_grid(psmc_plot,msmc_plot,cp, ncol = 1, align = "hv", axis = "lr", rel_heights = c(0.3,0.3,0.3))
```

## Reference





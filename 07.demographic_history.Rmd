---
title: "Demographic history - Sequentially Markov Cross-colalescence analysis"
output: 
  github_document:
    toc: TRUE
    toc_depth: 3
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.retina = 2)
library(tidyverse)
library(ggsci)
```

For both SMC++ and MSMC, we used SNPs from scaffolds with a length greater than 1Mbp which account for approximately 75% of genome size (N75=983,972, first 142 scaffolds).

## Mutation rate
The per generation mutation rate of *A.digitifera* estimated based on a divergence time of 15.5 Millions years is 2.89e-8 in [@Mao2018]. However, the divergence time in [@Shinzato2020] is 25-50 million years which give us a much smaller per generation mutation rate of 1.2e-8.

```bash
#(79427941/(79427942+363368171)/(2 × 15.5)) x 5 × 10−6 = 2.89 × 10−8
#calibrate divergence time to 37.5
(79427941/(79427942+363368171)/(2 × 37.5)) x 5 × 10−6 = 1.20 x 10-8
```

## SMC++ analysis
We used all 75 samples in smc++ analysis. 
Firstly, a single vcf was extracted for every scaffold and indexed.

```bash
bcftools view -r {chr} -Oz -o {chr}.vcf.gz Adigi.v2.filtered.vcf.gz 
tabix {chr}.vcf.gz
```
To distinguish invariant positions with missing data, we mask genome regions a) with low or super high coverage across all samples (less than three reads covered or greater than 3000) b) We generated the genome mask files created using Heng Li's SNPable tools and extracted the ambigous positions (c=="0" or c=="1").

```bash
samtools depth -r {chr} -aa -f bamfiles.txt | \
awk '{sum=0; for(i=3; i<=NF; i++) {sum+=$i}; print $1"\t"$2"\t"sum }' | \
awk '{if($3<3 || $3>3000) print $1"\t"$2"\t"$2}' | \
bedtools merge -i stdin | bgzip > {chr}.low_masked.bed.gz

zcat {chr}.low_masked.bed.gz Adigi_{chr}.mask.bed.gz | bedtools sort | bedtools merge |bgzip > {chr}.masked.bed.gz
```
Mask files of all scaffolds were concatenated together and we keep blocks with a length greater than 2kb. Next, vcf files were converted into a smc format file using `vcf2smc` in which we send a vcf file of one scaffold and specify a list samples in the population.

```bash
smc++ vcf2smc --mask all.masked.bed.gz {chr}.vcf.gz {pop}.{chr}.smc.gz {chr} POP:{sampleid},..
```
smc++ `estimate` mode was run to fit population size history to data for each population.

```bash
smc++ estimate --cores 30 -o estimate --base {pop} --spline cubic \
 --timepoints 20 200000 --em-iterations 50 --thinning 3000 --knots 10 1.2e-8 {pop}.*.smc.gz
```

```{r plot-seting}
mu <- 1.2e-8 
gen <- 5
dtime = data.frame(name=c("LGM","Holocene"), start=c(1.2e+4,0), end=c(1.1e+5,1.2e+4))
smc <- read_csv("data/hpc/demography/estimate_em50_cubic_k10/em50_cubic_k10.csv")

xbreaks <- c(1e+2*1:9, 1e+3*1:9 , 1e+4*1:9 , 1e+5*1:9 , 1e+6*1:9 , 1e+7)
xlabels <- as.character(xbreaks)
xlabels[!(xbreaks%in%c(1e+3,1e+4,1e+5,1e+6,1e+7))] <- ''
xlabels[xbreaks%in%c(1e+3,1e+4,1e+5,1e+6,1e+7)] <-c("1kya","10kya","100kya","1mya","10mya")

ybreaks <- c(1e+3*2:9 , 1e+4*1:9 , 1e+5*1:9 , 1e+6*1:2)
ylabels <- as.character(ybreaks)
ylabels[!(ybreaks%in%c(1e+4,1e+5,1e+6))] <- ''
ylabels[ybreaks%in%c(1e+4,1e+5,1e+6)] <- c("1","10","100")
```

```{r smc-plot, fig.align='center',fig.width=7,fig.height=5, fig.cap="The effective population size estimate using SMC++ approach. The red, blue, and green lines represent the results of inshore, offshore north, and offshore south respectively."}
ggplot(smc) + geom_line(aes(x=x,y=y,color=label),size=0.8,show.legend = FALSE) +
  geom_rect(data=dtime,aes(xmin=start,xmax=end,fill=name),ymin=-Inf, ymax=Inf,alpha=0.2,show.legend = FALSE) + 
  scale_fill_manual(values = c("yellow","grey")) +
  geom_text(data=dtime, aes(x=c(3e+4,2e+3),y=2e+6,label=name), size=4, fontface="bold") +
  scale_x_log10(breaks=xbreaks, labels=xlabels)+
  scale_y_log10(breaks=ybreaks,labels=ylabels,limits=c(2e+3,2e+6)) + 
  scale_color_startrek() + theme_test() + 
  labs(x=expression(paste("Years Ago (g=5, ",mu, "=1.20e-8)")),
  y=expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")"))) +
  ggtitle("Historial effective population size estimated by SMC++")
```

### The separation time between populations.

The smc++ can estimate joint demography and speculate the splitting time between pair of populations. First, we create a joint frequency spectrum for every pair of populations using `vcf2smc`.

```bash
smc++ vcf2smc {chr}.vcf.gz {pop1}_{pop2}.smc.gz {chr} POP1:{sampleid},..  POP2:{sampleid},..
```

Next,we ran smc++ `split` with same parameters we used in `estimate`.

```bash
smc++ split -o split --base {pop1}_{pop2} \
--timepoints 20 200000 --em-iterations 50 --thinning 3000 \
{pop1}.final.json {pop2}.final.json {pop1}_{pop2}.smc.gz
```

```{r split, fig.show="hold", out.width="33%"}
library(png)
library(knitr)
split_plot <- list.files(path = "figures/",pattern = "*.split.png" ,full.names = TRUE)
include_graphics(split_plot)
```

**Figure:** Three figures above show the joint demography between any two population  (IN: inshore, NO:northoffshore, SO:southoffshore) and the estimated spliting time (blue vertical line).


### Bootstrap results 
We perform 20 bootstrap in SMC++
```{r}
smc_main <- read_csv("data/hpc/demography/estimate_em50_k40/em50_k40.csv") %>% select(label,x,y) %>% add_column(type="main")
read_bootstrap <- function(pop, n) {
  read_csv(paste0("data/hpc/demography/smc_bootstrap/",pop,"_",n,".csv" )) %>% select(label,x,y) %>% add_column(n=paste0("bs",n))
}

smc_bs <- rbind(map_df(1:20, ~read_bootstrap(pop="inshore",n=.x)),
                map_df(1:20, ~read_bootstrap(pop="northoffshore",n=.x)),
                map_df(1:20, ~read_bootstrap(pop="southoffshore",n=.x)))

```

```{r bootstrap-plot}
ggplot() + geom_line(data=smc_main,aes(x=x,y=y,color=label),size=1,show.legend = FALSE) +
  geom_line(data = smc_bs, aes(x=x,y=y,color=label,group=interaction(label,n)),alpha=0.1,show.legend = FALSE)+
  scale_x_log10(breaks=xbreaks, labels=xlabels)+
  scale_y_log10(breaks=ybreaks,labels=ylabels,limits=c(2e+3,2e+6)) + 
  scale_color_startrek() + theme_test() + 
  labs(x=expression(paste("Years Ago (g=5, ",mu, "=1.20e-8)")),
  y=expression(paste("Effective Population Size ",N[e]," (x", 10^4 ,")"))) +
  ggtitle("Historial effective population size estimated by SMC++ with 20 bootstraps")
```





